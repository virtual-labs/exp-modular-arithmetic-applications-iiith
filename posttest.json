{
  "version": 2.0,
  "questions": [
    {
      "question": "What is the result of 23 mod 6?",
      "answers": {
        "a": "3",
        "b": "4",
        "c": "5",
        "d": "6"
      },
      "explanations": {
        "a": "This is incorrect. When we divide 23 by 6, we get 23 = 6 × 3 + 5, so the remainder is 5, not 3.",
        "b": "This is incorrect. To find 23 mod 6, we divide 23 by 6: 23 ÷ 6 = 3 remainder 5, not 4.",
        "c": "This is correct! When we divide 23 by 6, we get 23 = 6 × 3 + 5, so the remainder (which is what 'mod' gives us) is 5. You can think of it as: starting from 0 and counting up by 6s (0, 6, 12, 18), the next step would be 24, but we only go to 23, leaving us 5 units past 18.",
        "d": "This is incorrect. The result of a mod operation is always less than the modulus. Since we're doing mod 6, the result must be between 0 and 5."
      },
      "correctAnswer": "c",
      "difficulty": "beginner"
    },
    {
      "question": "Which property makes RSA encryption secure?",
      "answers": {
        "a": "It uses very large prime numbers that are difficult to factor",
        "b": "It uses complex polynomial equations",
        "c": "It relies on the difficulty of solving linear equations",
        "d": "It uses random number generation for each message"
      },
      "explanations": {
        "a": "This is correct! RSA security is fundamentally based on the computational difficulty of factoring very large numbers that are products of two large primes. While multiplying two large primes is easy, factoring their product back into the original primes is computationally infeasible with current technology, especially when the primes are hundreds of digits long.",
        "b": "This is incorrect. RSA doesn't rely on polynomial equations. It uses modular arithmetic and the properties of prime numbers and Euler's totient function.",
        "c": "This is incorrect. RSA doesn't involve solving linear equations. The mathematical foundation is based on modular exponentiation and the difficulty of integer factorization.",
        "d": "This is incorrect. While good random number generation is important for key generation, the core security comes from the factorization problem, not randomness in message encryption."
      },
      "correctAnswer": "a",
      "difficulty": "beginner"
    },
    {
      "question": "In the RSA key generation process, what is the relationship between the public exponent e and Euler's totient function φ(n)?",
      "answers": {
        "a": "e must be a factor of φ(n)",
        "b": "e must be greater than φ(n)",
        "c": "e and φ(n) must be coprime (gcd(e, φ(n)) = 1)",
        "d": "e must equal φ(n) - 1"
      },
      "explanations": {
        "a": "This is incorrect. If e were a factor of φ(n), then gcd(e, φ(n)) would be greater than 1, which violates the requirement for e to be coprime to φ(n).",
        "b": "This is incorrect. In fact, e is typically much smaller than φ(n). Common values for e are 3, 17, or 65537, regardless of how large φ(n) is.",
        "c": "This is correct! For RSA to work properly, e and φ(n) must be coprime, meaning gcd(e, φ(n)) = 1. This ensures that e has a multiplicative inverse modulo φ(n), which becomes the private exponent d. If they weren't coprime, we couldn't find a value d such that e × d ≡ 1 (mod φ(n)).",
        "d": "This is incorrect. There's no requirement that e = φ(n) - 1. The only requirements are that e is coprime to φ(n) and 1 < e < φ(n)."
      },
      "correctAnswer": "c",
      "difficulty": "beginner"
    },
    {
      "question": "If p = 11 and q = 13, and we choose e = 7, what is the value of the private exponent d?",
      "answers": {
        "a": "103",
        "b": "23",
        "c": "31",
        "d": "67"
      },
      "explanations": {
        "a": "This is correct! First, n = p × q = 11 × 13 = 143, and φ(n) = (p-1) × (q-1) = 10 × 12 = 120. We need d such that e × d ≡ 1 (mod φ(n)), so 7 × d ≡ 1 (mod 120). Using the Extended Euclidean Algorithm or by testing: 7 × 103 = 721 = 6 × 120 + 1, so 7 × 103 ≡ 1 (mod 120). Therefore, d = 103.",
        "b": "This is incorrect. Let's verify: 7 × 23 = 161 = 1 × 120 + 41, so 7 × 23 ≡ 41 (mod 120), not 1.",
        "c": "This is incorrect. Let's verify: 7 × 31 = 217 = 1 × 120 + 97, so 7 × 31 ≡ 97 (mod 120), not 1.",
        "d": "This is incorrect. Let's verify: 7 × 67 = 469 = 3 × 120 + 109, so 7 × 67 ≡ 109 (mod 120), not 1."
      },
      "correctAnswer": "a",
      "difficulty": "intermediate"
    },
    {
      "question": "What is the result of 3^10 mod 11?",
      "answers": {
        "a": "1",
        "b": "3",
        "c": "9",
        "d": "5"
      },
      "explanations": {
        "a": "This is correct! We can solve this using Fermat's Little Theorem, which states that if p is prime and a is not divisible by p, then a^(p-1) ≡ 1 (mod p). Since 11 is prime and 3 is not divisible by 11, we have 3^10 ≡ 1 (mod 11). Alternatively, we can calculate step by step: 3^2 = 9, 3^4 = 81 ≡ 4 (mod 11), 3^8 ≡ 16 ≡ 5 (mod 11), 3^10 = 3^8 × 3^2 ≡ 5 × 9 ≡ 45 ≡ 1 (mod 11).",
        "b": "This is incorrect. While 3^1 ≡ 3 (mod 11), we need 3^10, which by Fermat's Little Theorem equals 1.",
        "c": "This is incorrect. 3^2 = 9, but 3^10 ≡ 1 (mod 11) by Fermat's Little Theorem.",
        "d": "This is incorrect. While 3^8 ≡ 5 (mod 11), we have 3^10 = 3^8 × 3^2 ≡ 5 × 9 ≡ 1 (mod 11)."
      },
      "correctAnswer": "a",
      "difficulty": "intermediate"
    },
    {
      "question": "In RSA, if you encrypt a message m with the public key (e, n) to get ciphertext c, and then encrypt c again with the same public key, what mathematical property ensures you don't get back the original message m?",
      "answers": {
        "a": "The commutative property of modular arithmetic",
        "b": "The fact that (m^e)^e ≢ m (mod n) in general",
        "c": "The irreversibility of prime factorization",
        "d": "The randomness in the encryption process"
      },
      "explanations": {
        "a": "This is incorrect. The commutative property states that a × b = b × a, but this doesn't explain why double encryption with the public key doesn't return the original message.",
        "b": "This is correct! When you encrypt m, you get c = m^e mod n. If you encrypt c again, you get c^e = (m^e)^e = m^(e²) mod n. For this to equal m, we would need m^(e²-1) ≡ 1 (mod n), which is not generally true. The exponent e² is not the multiplicative inverse of e modulo φ(n) - only d is. This is why you need the private key d to decrypt, not the public key e.",
        "c": "This is incorrect. While prime factorization difficulty is crucial for RSA security, it doesn't directly explain why double encryption with the same key doesn't work.",
        "d": "This is incorrect. RSA encryption is deterministic - the same message always produces the same ciphertext. There's no randomness in the basic RSA encryption process."
      },
      "correctAnswer": "b",
      "difficulty": "intermediate"
    },
    {
      "question": "Using the Extended Euclidean Algorithm, what is the modular multiplicative inverse of 25 modulo 31?",
      "answers": {
        "a": "5",
        "b": "6",
        "c": "25",
        "d": "30"
      },
      "explanations": {
        "a": "This is correct! Using the Extended Euclidean Algorithm: gcd(25,31) = gcd(25,6) = gcd(1,6) = 1. Working backwards: 1 = 31 - 5×6 = 31 - 5×(31-25) = 31 - 5×31 + 5×25 = 6×31 - 5×25. This gives us -5×25 ≡ 1 (mod 31), so 25×(-5) ≡ 1 (mod 31). Since -5 ≡ 26 (mod 31), we have 25×26 ≡ 1 (mod 31). Wait, let me recalculate: 25×5 = 125 = 4×31 + 1, so 25×5 ≡ 1 (mod 31).",
        "b": "This is incorrect. Let's verify: 25×6 = 150 = 4×31 + 26, so 25×6 ≡ 26 (mod 31), not 1.",
        "c": "This is incorrect. 25×25 = 625 = 20×31 + 5, so 25×25 ≡ 5 (mod 31), not 1.",
        "d": "This is incorrect. 25×30 = 750 = 24×31 + 6, so 25×30 ≡ 6 (mod 31), not 1."
      },
      "correctAnswer": "a",
      "difficulty": "advanced"
    },
    {
      "question": "In an RSA system with n = 77, e = 13, if the ciphertext is c = 46, what is the original message m?",
      "answers": {
        "a": "9",
        "b": "12",
        "c": "15",
        "d": "18"
      },
      "explanations": {
        "a": "This is incorrect. Let's verify: if m = 9, then c = 9^13 mod 77 = 58, not 46.",
        "b": "This is incorrect. Let's verify: if m = 12, then c = 12^13 mod 77 = 12, not 46.",
        "c": "This is incorrect. Let's verify: if m = 15, then c = 15^13 mod 77 = 64, not 46.",
        "d": "This is correct! First, find d: n = 77 = 7×11, so φ(n) = 6×10 = 60. We need d such that 13×d ≡ 1 (mod 60). Using the Extended Euclidean Algorithm: 13×37 = 481 = 8×60 + 1, so d = 37. To decrypt: m = c^d mod n = 46^37 mod 77 = 18. We can verify by encrypting: 18^13 mod 77 = 46."
      },
      "correctAnswer": "d",
      "difficulty": "advanced"
    },
    {
      "question": "What would happen to RSA security if quantum computers capable of running Shor's algorithm became widely available?",
      "answers": {
        "a": "RSA would become slightly less secure but still usable",
        "b": "RSA would be completely broken as Shor's algorithm can efficiently factor large integers",
        "c": "RSA would become more secure due to quantum encryption",
        "d": "Only the key generation process would need to be modified"
      },
      "explanations": {
        "a": "This is incorrect. Shor's algorithm doesn't just weaken RSA slightly - it completely breaks it by making factorization efficient.",
        "b": "This is correct! Shor's algorithm can factor large integers in polynomial time on a sufficiently powerful quantum computer, which would completely break RSA security. The algorithm can efficiently find the prime factors p and q of n, allowing an attacker to compute φ(n) and then the private key d. This is why cryptographers are actively developing post-quantum cryptographic algorithms that would be secure even against quantum computers.",
        "c": "This is incorrect. Quantum computing threatens RSA - it doesn't strengthen it. While quantum key distribution exists, it's a different technology and doesn't make RSA more secure.",
        "d": "This is incorrect. The entire RSA system would be broken, not just the key generation. Once the factors of n can be found efficiently, the whole cryptographic scheme becomes insecure."
      },
      "correctAnswer": "b",
      "difficulty": "advanced"
    }
  ]
}
